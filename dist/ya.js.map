{
  "version": 3,
  "file": "/home/salva/workspace/ya/.tmp/ya.js",
  "sources": [
    "ya.js"
  ],
  "names": [],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "define('ya',[], function () {\n\n  'use strict';\n\n  // In ES6, symbols are special objects that can be used to index other\n  // objects. As they are private to function scope, they become something\n  // like privates.\n\n  /* jshint newcap: false */\n  var id = Symbol();\n  var isReady = Symbol();\n  var isBlockedOnSelect = Symbol();\n  var trySelect = Symbol();\n  var result = Symbol();\n  var routineCanBeRescheduled = Symbol();\n  var canProceed = Symbol();\n  /* jshint newcap: true */\n\n  // The list of alive coroutines to be executed is ketp on a list.\n  var coroutines = [];\n  var nextTaskId = 1;\n\n  // This flag indicates if clear() method has been called. It's needed to\n  // abort execution from inside a routine.\n  var clearCalled;\n\n  // ya() function simply initializes the generator, then push it at the end of\n  // the coroutines list and start running them if the list is not empty.\n  function ya(generator) {\n    var args = [].slice.call(arguments, 1);\n    var task = generator.apply(undefined, args);\n    task[isReady] = true;\n    task[result] = undefined;\n    task[id] = nextTaskId++;\n    coroutines.push(task);\n    (coroutines.length === 1) && setTimeout(run);\n    return task[id];\n  }\n\n  // Run pÃ¬cks the last coroutine, execute it to the next yield and reschedule\n  // the routine.\n  function run() {\n    clearCalled = false;\n\n    // If there is no more coroutines, simply return without scheduling\n    // another run.\n    if (coroutines.length === 0) { return; }\n\n    // If there are coroutines, pick the last one. Default reschedule of the\n    // task consists into adding at the beginning.\n    var execution, done, promise,\n        scheduleOperation = 'unshift',\n        routine = coroutines.pop();\n\n    if (routine[isReady]) {\n\n      // Advances the routine to the next yield, return or error.\n      execution = runRoutine(routine);\n\n      // If clear has been called inside the execution of the coroutine, abort\n      // further execution and rescheduling.\n      if (clearCalled) { return; }\n\n      done = execution.done;\n      promise = execution.value;\n\n      // If the routine is over, don't reschedule.\n      if (done) {\n        scheduleOperation = null;\n      }\n\n      // When routine is not finished and it is returning a promise-like object,\n      // it means the routine is waiting for the result of that promise.\n      else if (promise && typeof promise.then === 'function') {\n\n        // The routine is marked as blocked to prevent the scheduler from\n        // running it.\n        routine[isReady] = false;\n\n        // And a fulfill callback is added to unblock the routine\n        // while saving the computation result for using when resuming the\n        // routine.\n        promise.then(function (data) {\n          routine[isReady] = true;\n          routine[result] = data;\n        });\n\n        // Some promises can ensure they will be resolved for the next run\n        // allowing the scheduler to reschedule the current routine immediately.\n        if (promise[routineCanBeRescheduled]) {\n          scheduleOperation = 'push';\n        }\n\n        // Copy runtime information to the routine.\n        routine[isBlockedOnSelect] = promise[isBlockedOnSelect];\n        routine[trySelect] = promise[trySelect];\n      }\n    }\n\n    // If routine is not ready but it's blocking on a select, try the select\n    // again.\n    else if (routine[isBlockedOnSelect]) {\n      var routineCanBeResumed = routine[trySelect]();\n      if (routineCanBeResumed) {\n        scheduleOperation = 'push';\n      }\n    }\n\n    // Reschedule the routine.\n    if (scheduleOperation) {\n      coroutines[scheduleOperation](routine);\n    }\n\n    // And schedule another run.\n    setTimeout(run);\n  }\n\n  // The function is isolated to minimize the impact of the try-catch.\n  function runRoutine(routine) {\n    var lastResult, execution, executionError;\n\n    // Runs a single routine passing the channel promise's result from the last\n    // run. In case of blocking on channel's operations, the result will be\n    // sent values for get() operations or `undefined` for send() operations.\n    try {\n      lastResult = routine[result];\n      routine[result] = undefined;\n      execution = routine.next(lastResult);\n    }\n\n    // If there is an error during the execution, the task is aborted and the\n    // onerror callback is called with an error object with the task id and the\n    // real error.\n    catch (e) {\n      if (typeof ya.onerror === 'function') {\n        executionError = { taskId: routine[id], error: e };\n        ya.onerror(executionError);\n      }\n      // A fake execution is crafted to terminate the execution of the failing\n      // routine.\n      execution = { done: true };\n    }\n\n    return execution;\n  }\n\n  // The channel function returns a new channel object to be used to communicate\n  // between coroutines. When coroutines send values and there are no consumers\n  // the sender blocks. The same happens for coroutines getting values when\n  // there are no values to be consumed.\n  //\n  // If a capacity is passed to the channel, then the channel is said to be\n  // buffered and it won't block senders until completely filled. The capacity\n  // value means how many unattended send() calls are allowed before blocking.\n  //\n  // For instance a 3 buffered channel will block a coroutine if this is\n  // sending the fourth item or greater.\n  function channel(capacity) {\n\n    // An unbuffered channel does not allow any unattended item. Each send()\n    // call will block unless there is a getter waiting for the value.\n    capacity = capacity || 0;\n\n    // When a value is sent to the channel but there is no one asking for that\n    // value, we promise the sender that someone will retrieve the value and we\n    // add a the promise resolver and the sent value to this collection.\n    var toBeRetrievedPromises = [];\n\n    // When a value is requested from the channel but there is no data available\n    // we promise the getter that someone will send a value to be consumed and\n    // we add the resolver for that promise.\n    var toBeFilledPromises = [];\n\n    // The channel object consists in two methods: get() and send().\n    var channelInterface = {\n      // get() is for retrieving values from the channel.\n      get: function get() {\n        var promiseForTheGetter;\n\n        // First check if there are values to be consumed. If so, there will be\n        // promises' resolvers in addition to the values being sent.\n        if (toBeRetrievedPromises.length > 0) {\n\n          // Each promise entry consists on a value and the resolver to tell\n          // the sender that its value is about to be consumed and it will\n          // be unblocked.\n          var resolver, value,\n              entry = toBeRetrievedPromises.shift();\n\n          resolver = entry.resolver;\n          value = entry.value;\n\n          // Unblocks the sender! But notice it won't be executed until run\n          // will be called again.\n          //\n          // The check about existence of the resolver is needed as buffered\n          // channels may not require to always warn senders.\n          resolver && resolver();\n\n          // As the collection of unattended items has shifted, it's possible\n          // for a blocked routine to have entered into the buffered section\n          // of the channel. If so, the routine can be unblocked.\n          if (capacity > 0 &&\n              toBeRetrievedPromises.length >= capacity) {\n            resolver = toBeRetrievedPromises[capacity - 1].resolver;\n            toBeRetrievedPromises[capacity - 1].resolver = null;\n            resolver && resolver();\n          }\n\n          // We will return an already solved promise to the getter with the\n          // value to be consumed.\n          promiseForTheGetter = Promise.resolve(value);\n\n          // The scheduler is informed it can reschedule the coroutine\n          // immediately.\n          promiseForTheGetter[routineCanBeRescheduled] = true;\n        }\n\n        // In the other hand, if there are no values to be consumed, we make\n        // a promise and leave the resolver as a way for the getter to be\n        // notified when a value is available.\n        else {\n          promiseForTheGetter = new Promise(function (resolver) {\n            toBeFilledPromises.push({ resolver: resolver });\n          });\n        }\n\n        return promiseForTheGetter;\n      },\n\n      // send() is for sending values to the channel.\n      send: function send(value) {\n        var promiseForTheSender;\n\n        // First check if there are petitioners waiting to be provided with\n        // values for consuming.\n        if (toBeFilledPromises.length > 0) {\n\n          // Each entry simply consists in a resolver to notify the getter with\n          // the sending value.\n          var resolver = toBeFilledPromises.shift().resolver;\n\n          // Unblocks the getter! And again, it won't be executed until the\n          // next run.\n          resolver(value);\n\n          // We will return an already resolved promise to the sender saying\n          // its value has been consumed immediately.\n          promiseForTheSender = Promise.resolve();\n\n          // And again, the promise will inform the scheduler it can\n          // reschedule the routine immediately.\n          promiseForTheSender[routineCanBeRescheduled] = true;\n        }\n\n        // If there are no petitioners waiting for values, promise the sender\n        // its value will be consumed by enqueuing a pair of promise resolver\n        // and the value to be consumed.\n        else {\n\n          var isFull = toBeRetrievedPromises.length >= capacity;\n\n          // If the buffer is not full, the promise can be fulfilled and the\n          // routine can be immediately resumed.\n          if (!isFull) {\n            promiseForTheSender = Promise.resolve();\n            toBeRetrievedPromises.push({ resolver: null, value: value });\n            promiseForTheSender[routineCanBeRescheduled] = true;\n          }\n\n          // But if it's full, then the promise remains and the sender will\n          // block until someone consumes the value.\n          else {\n            promiseForTheSender = new Promise(function (resolver) {\n              toBeRetrievedPromises.push({ resolver: resolver, value: value });\n            });\n          }\n        }\n\n        return promiseForTheSender;\n      }\n    };\n\n    // This is a private method implemented through the use of a symbol.\n    // The `channel#canProceed()` method return `true` if the channel is ready\n    // to send or get a value without blocking the routine. It is equivalent\n    // to check if the returning promise will have the `routineCanBeRescheduled`\n    // set.\n    channelInterface[canProceed] = function (type) {\n\n      // A channel is ready for a `get` operation if there are waiting\n      // producers.\n      if (type === 'get') {\n        return toBeRetrievedPromises.length > 0;\n      }\n\n      // A channel is ready for a `send` operation if there are waiting\n      // consumers or if the channel is not yet full.\n      else if (type === 'send') {\n        return toBeFilledPromises.length > 0 ||\n               toBeRetrievedPromises.length < capacity;\n      }\n\n      // Throw if the operation is not recognized.\n      else {\n        throw new Error('Channel operation unknown');\n      }\n    };\n    return channelInterface;\n  }\n\n  // Select implements https://golang.org/ref/spec#Select_statements\n  // Read it first, it's eeeeeasy (or read the API docs).\n  function select() {\n    var selectPromise, resolveSelectPromise;\n\n    // Obtain clauses classified by nature.\n    var classifiedClauses = classifyClauses([].slice.call(arguments, 0));\n    var defaultClause = classifiedClauses.defaultClause;\n    var caseClauses = classifiedClauses.caseClauses;\n\n    // Now look for a ready case clause, i. e. a case clause with a channel\n    // ready for the specified operation.\n    var readyCase = chooseReadyCase(caseClauses);\n\n    // If there is one, perform the channel operation and attach the clause\n    // callback.\n    if (readyCase) {\n      selectPromise = readyCase.doChannelOperation();\n      selectPromise.then(readyCase.callback);\n    }\n\n    // If not but there is a default clause, perform the default callback.\n    else if (defaultClause) {\n      selectPromise = Promise.resolve();\n      selectPromise.then(defaultClause.callback);\n      selectPromise[routineCanBeRescheduled] = true;\n    }\n\n    // If there is no ready channel and there is no default, block.\n    else {\n      selectPromise = new Promise(function (resolve) {\n        resolveSelectPromise = resolve;\n      });\n\n      // As `routineCanBeRescheduled` this is more execution information. It\n      // informs the routine is blocked on a `select` and provide a method to\n      // recheck channel readyness.\n      // TODO: Find a way to pass the execution information separately.\n      selectPromise[isBlockedOnSelect] = true;\n      selectPromise[trySelect] = _trySelect;\n    }\n    return selectPromise;\n\n    // The function selects a ready case clause. A ready case is that whose\n    // channel operation can be performed.\n    function chooseReadyCase(cases) {\n      var choosen = null;\n      var readyClauses = [];\n      cases.forEach(function (caseClause) {\n        var channelCanProceed = caseClause.channel[canProceed](caseClause.type);\n        if (channelCanProceed) {\n          readyClauses.push(caseClause);\n        }\n      });\n\n      // If there are more than one, select one randomly.\n      if (readyClauses.length) {\n        var randomIndex = Math.floor(Math.random() * readyClauses.length);\n        choosen = readyClauses[randomIndex];\n      }\n\n      return choosen;\n    }\n\n    // The function re-check the select returning `true` if the select could\n    // choose some ready channel or not. It's equivalent to foresee if the\n    // returning promise from the channel operation will carry the\n    // `routineCanBeRescheduled` flag set to `true`.\n    function _trySelect() {\n\n      // Choose one clause.\n      var readyClause = chooseReadyCase(caseClauses);\n\n      // If there are no ready channels...\n      if (!readyClause) {\n        return false;\n      }\n\n      // If there are, associate the returned select promise with the channel\n      // one and carry the `routineCanBeRescheduled` flag.\n      else {\n        var channelPromise = readyClause.doChannelOperation();\n        channelPromise.then(function (value) { resolveSelectPromise(value); });\n        selectPromise.then(readyClause.callback);\n        selectPromise[routineCanBeRescheduled] =\n          channelPromise[routineCanBeRescheduled];\n        return selectPromise[routineCanBeRescheduled];\n      }\n    }\n  }\n\n  // Pass through a collection of clauses and classify them into **case** and\n  // **default** clause. Only one **dafeault** clause is allowed.\n  function classifyClauses(clauses) {\n    var defaultClause, caseClauses = [];\n    clauses.forEach(function (clause) {\n      if (clause instanceof DefaultClause && !defaultClause) {\n        defaultClause = clause;\n      }\n\n      // Throw if more than one **default** clause is found.\n      else if (clause instanceof DefaultClause) {\n        throw new Error('Two default clauses in the same select.');\n      }\n\n      else {\n        caseClauses.push(clause);\n      }\n    });\n\n    return {\n      defaultClause: defaultClause,\n      caseClauses: caseClauses\n    };\n  }\n\n  // The **case** factory returns a `CaseClause` instance.\n  // TODO: Refactor to use a future `CaseClause` class.\n  function $case(type) {\n    var caseClause = { type: type };\n    if (type === 'get' || type === '<-') {\n      caseClause.type = 'get';\n      caseClause.channel = arguments[1];\n      caseClause.callback = arguments[2];\n    }\n    else if (type === 'send' || type === '->') {\n      caseClause.type = 'send';\n      caseClause.sendingValue = arguments[1];\n      caseClause.channel = arguments[2];\n      caseClause.callback = arguments[3];\n    }\n    else {\n      throw new Error('Unknown channel operation.');\n    }\n    caseClause.doChannelOperation = function () {\n      return caseClause.channel[caseClause.type](caseClause.sendingValue);\n    };\n    return caseClause;\n  }\n\n  // The **default** factory returns a `DefaultClause` instance.\n  function $default(callback) {\n    return new DefaultClause(callback);\n  }\n\n  // The `DefaultClause` instance holds no mistiries inside.\n  function DefaultClause(callback) {\n    this.callback = callback;\n  }\n\n  // The `clear()` method empties the coroutines list avoiding run to executed\n  // and stablishes the `clearCalled` flag to be checked in those cases\n  // `clear()` is called from inside a routine.\n  function clear() {\n    coroutines = [];\n    clearCalled = true;\n  }\n\n  // Assemble the module and publish.\n  var yaInterface = {\n    channel: channel,\n    clear: clear,\n    select: select,\n    $case: $case,\n    $default: $default\n  };\n  for (var method in yaInterface) {\n    if (yaInterface.hasOwnProperty(method)) {\n      ya[method] = yaInterface[method];\n    }\n  }\n  return ya;\n});\n\n"
  ]
}