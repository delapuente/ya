{
  "version": 3,
  "file": "/home/salva/workspace/ya/.tmp/ya.js",
  "sources": [
    "ya.js"
  ],
  "names": [],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "define('ya',[], function () {\n\n  'use strict';\n\n  // In ES6, symbols are special objects that can be used to index other\n  // objects. As they are private to function scope, they become something\n  // like privates.\n\n  /* jshint newcap: false */\n  var id = Symbol();\n  var isReady = Symbol();\n  var result = Symbol();\n  var routineCanBeRescheduled = Symbol();\n  var isNonBlockingSend = Symbol();\n  /* jshint newcap: true */\n\n  // The list of alive coroutines to be executed is ketp on a list.\n  var coroutines = [];\n  var nextTaskId = 1;\n\n  // This flag indicates if clear() method has been called. It's needed to\n  // abort execution from inside a routine.\n  var clearCalled;\n\n  // ya() function simply initializes the generator, then push it at the end of\n  // the coroutines list and start running them if the list is not empty.\n  function ya(generator) {\n    var args = [].slice.call(arguments, 1);\n    var task = generator.apply(undefined, args);\n    task[isReady] = true;\n    task[result] = undefined;\n    task[id] = nextTaskId++;\n    coroutines.push(task);\n    (coroutines.length === 1) && setTimeout(run);\n    return task[id];\n  }\n\n  // Run pÃ¬cks the last coroutine, execute it to the next yield and reschedule\n  // the routine.\n  function run() {\n    clearCalled = false;\n\n    // If there is no more coroutines, simply return without scheduling\n    // another run.\n    if (coroutines.length === 0) { return; }\n\n    // If there are coroutines, pick the last one. Default reschedule of the\n    // task consists into adding at the beginning.\n    var execution, done, promise,\n        scheduleOperation = 'unshift',\n        routine = coroutines.pop();\n\n    if (routine[isReady]) {\n\n      // Advances the routine to the next yield, return or error.\n      execution = runRoutine(routine);\n\n      // If clear has been called inside the execution of the coroutine, abort\n      // further execution and rescheduling.\n      if (clearCalled) { return; }\n\n      done = execution.done;\n      promise = execution.value;\n\n      // If the routine is over, don't reschedule.\n      if (done) {\n        scheduleOperation = null;\n      }\n\n      // When routine is not finished and it is returning a promise-like object,\n      // it means the routine is waiting for the result of that promise.\n      else if (promise && typeof promise.then === 'function') {\n\n        // The routine is marked as blocked to prevent the scheduler from\n        // running it.\n        routine[isReady] = false;\n\n        // And a fulfill callback is added to unblock the routine\n        // while saving the computation result for using when resuming the\n        // routine.\n        promise.then(function (data) {\n          routine[isReady] = true;\n          routine[result] = data;\n        });\n\n        // Some promises can ensure they will be resolved for the next run\n        // allowing the scheduler to reschedule the current routine immediately.\n        if (promise[routineCanBeRescheduled]) {\n          scheduleOperation = 'push';\n        }\n      }\n\n    }\n\n    // Reschedule the routine.\n    if (scheduleOperation) {\n      coroutines[scheduleOperation](routine);\n    }\n\n    // And schedule another run.\n    setTimeout(run);\n  }\n\n  // The function is isolated to minimize the impact of the try-catch.\n  function runRoutine(routine) {\n    var lastResult, execution, executionError;\n\n    // Runs a single routine passing the channel promise's result from the last\n    // run. In case of blocking on channel's operations, the result will be\n    // sent values for get() operations or `undefined` for send() operations.\n    try {\n      lastResult = routine[result];\n      routine[result] = undefined;\n      execution = routine.next(lastResult);\n    }\n\n    // If there is an error during the execution, the task is aborted and the\n    // onerror callback is called with an error object with the task id and the\n    // real error.\n    catch (e) {\n      if (typeof ya.onerror === 'function') {\n        executionError = { taskId: routine[id], error: e };\n        ya.onerror(executionError);\n      }\n      // A fake execution is crafted to terminate the execution of the failing\n      // routine.\n      execution = { done: true };\n    }\n\n    return execution;\n  }\n\n  // The channel function returns a new channel object to be used to communicate\n  // between coroutines. When coroutines send values and there are no consumers\n  // the sender blocks. The same happens for coroutines getting values when\n  // there are no values to be consumed.\n  //\n  // If a capacity is passed to the channel, then the channel is said to be\n  // buffered and it won't block senders until completely filled. The capacity\n  // value means how many unattended send() calls are allowed before blocking.\n  //\n  // For instance a 3 buffered channel will block a coroutine if this is\n  // sending the fourth item or greater.\n  function channel(capacity) {\n\n    // An unbuffered channel does not allow any unattended item. Each send()\n    // call will block unless there is a getter waiting for the value.\n    capacity = capacity || 0;\n\n    // When a value is sent to the channel but there is no one asking for that\n    // value, we promise the sender that someone will retrieve the value and we\n    // add a the promise resolver and the sent value to this collection.\n    var toBeRetrievedPromises = [];\n\n    // When a value is requested from the channel but there is no data available\n    // we promise the getter that someone will send a value to be consumed and\n    // we add the resolver for that promise.\n    var toBeFilledPromises = [];\n\n    // The channel object consists in two methods: get() and send().\n    return {\n      // get() is for retrieving values from the channel.\n      get: function get() {\n        var promiseForTheGetter;\n\n        // First check if there are values to be consumed. If so, there will be\n        // promises' resolvers in addition to the values being sent.\n        if (toBeRetrievedPromises.length > 0) {\n\n          // Each promise entry consists on a value and the resolver to tell\n          // the sender that its value is about to be consumed and it will\n          // be unblocked.\n          var resolver, value,\n              entry = toBeRetrievedPromises.shift();\n\n          resolver = entry.resolver;\n          value = entry.value;\n\n          // Unblocks the sender! But notice it won't be executed until run\n          // will be called again.\n          //\n          // The check about existence of the resolver is needed as buffered\n          // channels may not require to always warn senders.\n          resolver && resolver();\n\n          // As the collection of unattended items has shifted, it's possible\n          // for a blocked routine to have entered into the buffered section\n          // of the channel. If so, the routine can be unblocked.\n          if (capacity > 0 &&\n              toBeRetrievedPromises.length >= capacity) {\n            resolver = toBeRetrievedPromises[capacity - 1].resolver;\n            toBeRetrievedPromises[capacity - 1].resolver = null;\n            resolver && resolver();\n          }\n\n          // We will return an already solved promise to the getter with the\n          // value to be consumed.\n          promiseForTheGetter = Promise.resolve(value);\n\n          // The scheduler is informed it can reschedule the coroutine\n          // immediately.\n          promiseForTheGetter[routineCanBeRescheduled] = true;\n        }\n\n        // In the other hand, if there are no values to be consumed, we make\n        // a promise and leave the resolver as a way for the getter to be\n        // notified when a value is available.\n        else {\n          promiseForTheGetter = new Promise(function (resolver) {\n            toBeFilledPromises.push({ resolver: resolver });\n          });\n        }\n\n        return promiseForTheGetter;\n      },\n\n      // send() is for sending values to the channel.\n      send: function send(value) {\n        var promiseForTheSender;\n\n        // First check if there are petitioners waiting to be provided with\n        // values for consuming.\n        if (toBeFilledPromises.length > 0) {\n\n          // Each entry simply consists in a resolver to notify the getter with\n          // the sending value.\n          var resolver = toBeFilledPromises.shift().resolver;\n\n          // Unblocks the getter! And again, it won't be executed until the\n          // next run.\n          resolver(value);\n\n          // We will return an already resolved promise to the sender saying\n          // its value has been consumed immediately.\n          promiseForTheSender = Promise.resolve();\n\n          // And again, the promise will inform the scheduler it can\n          // reschedule the routine immediately.\n          promiseForTheSender[isNonBlockingSend] = true;\n        }\n\n        // If there are no petitioners waiting for values, promise the sender\n        // its value will be consumed by enqueuing a pair of promise resolver\n        // and the value to be consumed.\n        else {\n\n          var isFull = toBeRetrievedPromises.length >= capacity;\n\n          // If the buffer is not full, the promise can be fulfilled and the\n          // routine can be immediately resumed.\n          if (!isFull) {\n            promiseForTheSender = Promise.resolve();\n            toBeRetrievedPromises.push({ resolver: null, value: value });\n            promiseForTheSender[routineCanBeRescheduled] = true;\n          }\n\n          // But if it's full, then the promise remains and the sender will\n          // block until someone consumes the value.\n          else {\n            promiseForTheSender = new Promise(function (resolver) {\n              toBeRetrievedPromises.push({ resolver: resolver, value: value });\n            });\n          }\n        }\n\n        return promiseForTheSender;\n      }\n    };\n  }\n\n  // The `clear()` method empties the coroutines list avoiding run to executed\n  // and stablishes the `clearCalled` flag to be checked in those cases\n  // `clear()` is called from inside a routine.\n  function clear() {\n    coroutines = [];\n    clearCalled = true;\n  }\n\n  // Assemble the module and publish.\n  ya.channel = channel;\n  ya.clear = clear;\n  return ya;\n});\n\n"
  ]
}